В Jetpack Compose CompositionLocal` в Jetpack Compose позволяет дочерним элементам получать доступ к данным, предоставленным выше по иерархии композиций, без необходимости явно передавать эти данные через параметры функций. Это упрощает обмен данными между компонентами и делает код более чистым и поддерживаемым.

Распространённым примером является `LocalContext.current`, который позволяет получить текущий `Context` (обычно контекст Activity) внутри функции, помеченной аннотацией `@Composable`. Мы часто используем `LocalContext.current`, поскольку наши composable-функции являются частью Activity, и доступ к контексту может быть полезен для таких задач, как запуск новой Activity, доступ к ресурсам или использование системных сервисов.

Также можно применять в навигации, чтобы логику навигации писать на каждом конкретном экране, а не передавать в аргументы эту логику и уже реализовать ее на самом верху иерархии. Например, вы можете создать `NavController` в верхнем уровне иерархии с помощью `val navController = rememberNavController()` и предоставить его дочерним компонентам через `CompositionLocalProvider(LocalNavController provides navController)`. Это позволяет дочерним компонентам получать доступ к `navController` через `LocalNavController.current` и управлять навигацией без явной передачи контроллера через параметры функций.

В Jetpack Compose существуют два способа создания `CompositionLocal`: `compositionLocalOf` и `staticCompositionLocalOf`. Они различаются в поведении при изменении предоставленного значения и, следовательно, в подходах к их использованию.

**`compositionLocalOf`**: Когда значение, предоставленное через `compositionLocalOf`, изменяется, Jetpack Compose отслеживает места, где это значение используется, и выполняет повторную композицию только этих конкретных компонентов. Это делает `compositionLocalOf` подходящим для данных, которые могут часто меняться, поскольку минимизирует объем повторных композиций и повышает производительность.

**`staticCompositionLocalOf`**: В отличие от `compositionLocalOf`, чтения из `staticCompositionLocalOf` не отслеживаются Compose. Это означает, что при изменении значения, предоставленного через `staticCompositionLocalOf`, повторной композиции подвергается весь контент внутри `CompositionLocalProvider`, а не только те места, где это значение используется. Поэтому `staticCompositionLocalOf` рекомендуется использовать для значений, которые редко или никогда не меняются, чтобы избежать ненужных повторных композиций и сохранить производительность.

![[CompositionLocal.png]]